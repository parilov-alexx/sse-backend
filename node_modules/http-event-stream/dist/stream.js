"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createLowLevelStream(res, options) {
    if (res.headersSent) {
        throw new Error('Cannot create SSE event stream: Headers have already been sent to client.');
    }
    // Chrome chokes upon double-newline separated comment blocks without data,
    // so make sure we always make comments part of a data message block
    var stillInCommentBlock = false;
    var autoCloseTimer;
    var eventStream = {
        sendMessage: function (event) {
            var lines = [];
            var data = Array.isArray(event.data) ? event.data : [event.data];
            if (stillInCommentBlock) {
                lines.push('');
            }
            if (event.event) {
                lines.push("event:" + event.event);
            }
            if (event.id) {
                lines.push("id:" + event.id);
            }
            if (event.retry) {
                lines.push("retry:" + event.retry);
            }
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var dataItem = data_1[_i];
                for (var _a = 0, _b = dataItem.replace(/(\r\n|\r)/g, '\n').split('\n'); _a < _b.length; _a++) {
                    var dataItemLine = _b[_a];
                    lines.push("data:" + dataItemLine);
                }
            }
            res.write(lines.join('\n') + '\n\n');
            stillInCommentBlock = false;
            // Auto-close feature: In case this is a request made by a non-compatible browser; allows polyfilling
            if (options.autoCloseFast && !autoCloseTimer) {
                autoCloseTimer = setTimeout(function () { return eventStream.close(); }, 1);
            }
        },
        sendComment: function (comment) {
            res.write(':' + comment + '\n');
            stillInCommentBlock = true;
        },
        close: function () {
            res.end();
        }
    };
    initStream(eventStream, res, options);
    return eventStream;
}
exports.createLowLevelStream = createLowLevelStream;
function initStream(stream, res, options) {
    var autoCloseFast = options.autoCloseFast, _a = options.keepAliveInterval, keepAliveInterval = _a === void 0 ? 20000 : _a;
    if (keepAliveInterval > 0) {
        var keepAliveIntervalID_1 = setInterval(function () {
            stream.sendComment('keep-alive');
        }, keepAliveInterval);
        res.on('close', function () {
            clearInterval(keepAliveIntervalID_1);
        });
        res.on('finish', function () {
            clearInterval(keepAliveIntervalID_1);
        });
    }
    if (options.onClose) {
        res.connection.on('close', options.onClose);
    }
    res.connection.setNoDelay(true);
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': autoCloseFast ? 'close' : 'keep-alive'
    });
    stream.sendComment('ok');
    return stream;
}
